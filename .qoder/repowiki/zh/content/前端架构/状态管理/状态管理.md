# 状态管理

<cite>
**本文档引用的文件**
- [useAppStore.ts](file://frontend/src/store/useAppStore.ts)
- [useBusinessData.ts](file://frontend/src/hooks/useBusinessData.ts)
- [useZodForm.ts](file://frontend/src/hooks/forms/useZodForm.ts)
- [useEmployees.ts](file://frontend/src/hooks/business/useEmployees.ts)
- [useFlows.ts](file://frontend/src/hooks/business/useFlows.ts)
- [useApiQuery.ts](file://frontend/src/utils/useApiQuery.ts)
- [http.ts](file://frontend/src/api/http.ts)
- [api.ts](file://frontend/src/config/api.ts)
- [cache.ts](file://frontend/src/config/cache.ts)
- [PrivateRoute.tsx](file://frontend/src/router/PrivateRoute.tsx)
</cite>

## 目录
1. [简介](#简介)
2. [全局状态管理](#全局状态管理)
3. [数据获取与缓存](#数据获取与缓存)
4. [表单验证与状态管理](#表单验证与状态管理)
5. [状态流图](#状态流图)
6. [错误处理与加载状态](#错误处理与加载状态)
7. [总结](#总结)

## 简介
本系统采用Zustand管理全局状态，React Query处理数据获取和缓存，并通过自定义Hook抽象业务逻辑。全局状态包括用户会话、权限配置和UI状态，而局部状态则通过React Query的查询和变更机制管理。系统还实现了统一的API请求逻辑和基于Zod的表单验证。

## 全局状态管理

系统使用Zustand库创建`useAppStore`来管理全局状态，包括用户认证信息、UI状态和主题模式。该状态通过`persist`中间件持久化到localStorage中，确保页面刷新后状态不丢失。

```mermaid
classDiagram
class AppState {
+collapsed : boolean
+themeMode : 'light' | 'dark'
+userInfo : UserInfo | null
+token : string | null
+isAuthenticated : boolean
+toggleCollapsed() : void
+setCollapsed(collapsed : boolean) : void
+toggleTheme() : void
+setThemeMode(mode : ThemeMode) : void
+setUserInfo(user : UserInfo | null) : void
+setToken(token : string | null) : void
+logout() : void
}
class UserInfo {
+id? : string
+email? : string
+name? : string
+username? : string
+role? : string
+permissions? : string[]
+position? : Position
}
class Position {
+code? : string
+name? : string
+level? : number
+functionRole? : string
+canManageSubordinates? : number
}
AppState --> UserInfo : "包含"
UserInfo --> Position : "包含"
```

**图示来源**
- [useAppStore.ts](file://frontend/src/store/useAppStore.ts#L23-L89)

**本节来源**
- [useAppStore.ts](file://frontend/src/store/useAppStore.ts#L1-L89)
- [PrivateRoute.tsx](file://frontend/src/router/PrivateRoute.tsx#L5-L12)
- [main.tsx](file://frontend/src/main.tsx#L38-L43)

## 数据获取与缓存

系统使用React Query通过`useApiQuery` Hook实现数据获取、缓存和轮询功能。`useBusinessData`抽象层封装了API请求逻辑，提供了统一的数据访问接口。

```mermaid
sequenceDiagram
participant Component as "组件"
participant Hook as "自定义Hook"
participant Query as "React Query"
participant API as "API客户端"
Component->>Hook : 调用useEmployees()
Hook->>Query : useApiQuery(['employees'], api.employees)
Query->>Query : 检查缓存(staleTime)
alt 缓存有效
Query-->>Hook : 返回缓存数据
else 缓存过期
Query->>API : 发起HTTP请求
API->>Backend : GET /api/v2/employees
Backend-->>API : 返回员工数据
API-->>Query : 解析响应
Query-->>Hook : 返回新数据并更新缓存
end
Hook-->>Component : 返回查询结果
```

**图示来源**
- [useApiQuery.ts](file://frontend/src/utils/useApiQuery.ts#L11-L41)
- [useBusinessData.ts](file://frontend/src/hooks/useBusinessData.ts#L6-L135)
- [http.ts](file://frontend/src/api/http.ts#L11-L115)

**本节来源**
- [useApiQuery.ts](file://frontend/src/utils/useApiQuery.ts#L1-L103)
- [useBusinessData.ts](file://frontend/src/hooks/useBusinessData.ts#L1-L136)
- [cache.ts](file://frontend/src/config/cache.ts#L5-L21)
- [api.ts](file://frontend/src/config/api.ts#L12-L188)

## 表单验证与状态管理

系统通过`useZodForm` Hook结合Zod Schema实现表单验证，将Ant Design的表单组件与Zod的类型安全验证相结合。`useBusinessData`抽象层统一了API请求逻辑，确保数据获取的一致性。

```mermaid
flowchart TD
Start([开始]) --> FormInit["初始化表单"]
FormInit --> ZodSchema["定义Zod Schema"]
ZodSchema --> UseZodForm["调用useZodForm(schema)"]
UseZodForm --> FormComponent["在组件中使用form实例"]
FormComponent --> UserInput["用户输入数据"]
UserInput --> Validate["调用validateWithZod()"]
Validate --> AntdValidate["form.validateFields()"]
AntdValidate --> ZodParse["schema.safeParse(values)"]
ZodParse --> Valid{"验证成功?"}
Valid --> |是| ReturnData["返回解析后的数据"]
Valid --> |否| TransformError["转换Zod错误为Antd格式"]
TransformError --> SetFields["form.setFields(errors)"]
SetFields --> ThrowError["抛出验证失败错误"]
ReturnData --> End([完成])
ThrowError --> End
```

**图示来源**
- [useZodForm.ts](file://frontend/src/hooks/forms/useZodForm.ts#L25-L60)
- [useBusinessData.ts](file://frontend/src/hooks/useBusinessData.ts#L6-L135)

**本节来源**
- [useZodForm.ts](file://frontend/src/hooks/forms/useZodForm.ts#L1-L61)
- [useBusinessData.ts](file://frontend/src/hooks/useBusinessData.ts#L1-L136)

## 状态流图

以下状态流图展示了从API请求到UI渲染的数据流动路径，包括查询、变更和缓存更新的完整流程。

```mermaid
graph TD
A[UI组件] --> B{数据需求}
B --> |读取数据| C[useQuery Hook]
B --> |修改数据| D[useMutation Hook]
C --> E{缓存检查}
E --> |命中| F[返回缓存数据]
E --> |未命中| G[发起API请求]
G --> H[API客户端]
H --> I[后端服务]
I --> J[数据库]
J --> I
I --> H
H --> K[处理响应]
K --> L[更新缓存]
L --> M[返回数据给组件]
D --> N[发起变更请求]
N --> H
H --> O[后端处理]
O --> P[数据库更新]
P --> Q[返回结果]
Q --> R[无效化相关查询]
R --> S[自动重新获取数据]
S --> C
F --> T[渲染UI]
M --> T
T --> A
style A fill:#4CAF50,stroke:#388E3C
style T fill:#2196F3,stroke:#1976D2
style H fill:#FF9800,stroke:#F57C00
style J fill:#9C27B0,stroke:#7B1FA2
```

**图示来源**
- [useApiQuery.ts](file://frontend/src/utils/useApiQuery.ts#L11-L41)
- [useEmployees.ts](file://frontend/src/hooks/business/useEmployees.ts#L36-L47)
- [useFlows.ts](file://frontend/src/hooks/business/useFlows.ts#L31-L41)
- [http.ts](file://frontend/src/api/http.ts#L11-L115)

## 错误处理与加载状态

系统实现了全面的错误处理和加载状态管理机制。React Query自动管理加载、错误和成功状态，而API客户端则处理网络错误和认证失效。

```mermaid
stateDiagram-v2
[*] --> Idle
Idle --> Loading : "发起请求"
Loading --> Success : "200 OK"
Loading --> Error : "网络错误/4xx/5xx"
Success --> Idle : "渲染数据"
Error --> HandleError : "处理错误"
HandleError --> ShowMessage : "显示错误消息"
ShowMessage --> Redirect["重定向(401)"]
ShowMessage --> Retry["重试选项"]
Redirect --> Login["跳转到登录页"]
Retry --> Loading
Login --> [*]
note right of Error
包括网络连接错误、
服务器错误(5xx)、
客户端错误(4xx)
end note
note right of HandleError
- 401 : 清除认证状态并重定向
- 其他 : 显示错误消息
- 可配置重试逻辑
end note
```

**图示来源**
- [http.ts](file://frontend/src/api/http.ts#L25-L83)
- [useApiQuery.ts](file://frontend/src/utils/useApiQuery.ts#L28-L31)
- [PrivateRoute.tsx](file://frontend/src/router/PrivateRoute.tsx#L10-L12)

**本节来源**
- [http.ts](file://frontend/src/api/http.ts#L1-L116)
- [useApiQuery.ts](file://frontend/src/utils/useApiQuery.ts#L1-L103)

## 总结
本系统通过Zustand、React Query和自定义Hook的组合，实现了高效的状态管理。全局状态由Zustand管理并持久化，数据获取由React Query处理缓存和同步，表单验证通过Zod和Ant Design集成实现。这种架构确保了状态的一致性、可预测性和可维护性。